/*   
 *   Пример использования библиотеки myEncoder, заодно проверка скорости работы.
 *   Как всегда накладные расходы при таком проверочном цикле составляют 200 мс за 50000 циклов.
 *   Длительность работы Enc.check = 875 мс, что составляет 17,5 мкс или 57 кГц,
 *   Но при этом не стоит забывать, что мы искусственно пропускаем часть проверок, чтобы ограничить частоту 
 *   опроса до 1 кГц. И в таком режиме в коротком главном цикле получаем 1 проверка = 5 мкс или частота 200 кГц. 
 *   Правила работы с библиотекой:
 *   - делаем инклюд: #include "myEncoder.h"
 *   - Запускаем конструктор класса CEncoder, который создает экземпляр этого класса, контролирующий отдельно
 *     взятый энкодер: CEncoder Enc(11,10,12);  
 *     Запускать конструктор надо вне setup, иначе экземпляры энкодеров будут доступны только внутри setup.
 *     Можно создавать несколько экземпляров этого класса и контролировать одновременно несколько энкодеров.
 *     Параметры конструктора - порты, к которым подключен энкодер, последний порт - кнопка. 
 *   - Если желаем узнать, не повернулся ли энкодер, запускаем метод check().
 *     Он возвращает 1 при повороте по часовой стрелке, -1 при повороте против часовой и 0, если поворота не было.
 *     Если перепутано направление поворота - нужно в конструкторе поменять местами 1 и 2 аргумент.
 *   - Если есть желание проверить нажата ли кнопка энкодера - запускаем метод button_down().
 *     Он возвращает TRUE, если кнопка НАЖАТА и FALSE, если кнопка не нажата. Дребезг контактов не отрабатывается.
 */ 


#include "myEncoder.h"

CEncoder Enc(11,10,12);

int Pos =0;
long mySec1;
long mySec2;

void setup() {
  Serial.begin(115200);
  pinMode(13,OUTPUT);
  digitalWrite(13,HIGH);
  mySec1 = 0;
  mySec2 = millis();
}

void loop() {
  Pos = Pos + Enc.check();
  Serial.println(Pos);
  mySec1++;
  //Enc.check();
  if (mySec1 == 50000){
    mySec2 = millis()-mySec2;
    for (int i =0; i < 1000; i++) Serial.println(mySec2);
  }
}
